embed
  {{ tex-preamble
    \setoperatorfont\mathsf
    \newcommand{\op}[1]{ \operatorname{#1} }
    \newcommand{\gap}{\:}
    \newcommand{\kw}[1]{ \mathsf{#1} }
  }}

indexvar i ::=
  {{ com sequence index }}
  {{ lex alphanum }}

metavar x, y, z ::=
  {{ com term variables }}
  {{ lex alphanum }}

metavar j ::=
  {{ com join point variables }}
  {{ lex alphanum }}

grammar

A :: 'valty_' ::= {{ com value types }}
  | ⊤ :: :: Unit
    {{ tex \top }}
  | A1 + A2 :: :: Sum
    {{ tex [[A1]] \mathbin{+} [[A2]] }}
  | U B :: :: Thunk
    {{ tex \kw{U} \gap [[B]] }}
  | ( A ) :: S :: Parens
    {{ com parentheses }}
    {{ tex ( [[A]] )}}

B :: 'comty_' ::= {{ com computation types }}
  | A → B :: :: Fun
    {{ tex [[A]] \mathbin{\to} [[B]] }}
  | B1 & B2 :: :: Pair
    {{ tex [[B1]] \mathbin{\&} [[B2]] }}
  | F A :: :: Return
    {{ tex \kw{F} \gap [[A]] }}
  | ( B ) :: S :: Parens
    {{ com parentheses }}
    {{ tex ( [[B]] )}}

T :: 'termty_' ::= {{ com ground types }}
  | ⊤ :: :: Unit
  | T1 + T2 :: :: Sum

C :: 'fakety_' ::= {{ com fake types }}
  | B1 ⇒ B2 :: :: Kont
    {{ tex [[B1]] \Rightarrow [[B2]] }}
  | A ↗ B :: :: Jump
    {{ tex [[A]] \mathbin{\nnearrow}\! [[B]]}}

v, w :: 'val_' ::= {{ com values }}
  | x :: :: Var
    {{ tex \mathit{[[x]]} }}
  | () :: :: Unit
    {{ tex (\gap) }}
  | inl v :: :: Inl
    {{ tex \kw{inl} \gap [[v]] }}
  | inr v :: :: Inr
    {{ tex \kw{inr} \gap [[v]] }}
  | true :: :: True
    {{ tex \kw{true} }}
  | false :: :: False
    {{ tex \kw{false} }}
  | { m } :: :: Thunk
    {{ tex \mathopen{\lbrace} [[m]] \mathclose{\rbrace} }}
  % substitution metafunctions
  | s ( x ) :: :: Subst
    {{ tex [[s]]([[x]]) }}
    {{ com single substitution into values }}
  | v { s } :: :: SubstsVal
    {{ com simultaneous substitution into values }}
    {{ tex [[v]] \mathopen{\lbrace} [[s]] \mathclose{\rbrace} }}
  % syntactic sugar for typesetting
  | _ :: :: Hole
    {{ com hole }}
    {{ tex \relax }}
  | v & :: S :: Align
    {{ com align after }}
    {{ tex [[v]] & }}
  | ( v ) :: S :: Parens
    {{ com parentheses }}
    {{ tex ([[v]]) }}
  | (# v #) :: S :: SParens
    {{ com invisible parentheses }}
    {{ tex [[v]] }}
  % translation
  | ⟦ v ⟧ :: :: CCNormVal
    {{ tex \llbracket [[v]] \rrbracket }}

m, n :: 'com_' ::= {{ com computations }}
  | v ! :: :: Force
    {{ tex [[v]] ! }}
  | return v :: :: Return
    {{ tex \kw{return} \gap [[v]] }}
  | let x ← n in m :: :: Let
    (+ bind x in m +)
    {{ tex \kw{let} \gap [[x]] \mathrel{\leftarrow} [[n]] \mathrel{ \kw{in} } [[m]] }}
  | λ x . m :: :: Fun
    (+ bind x in m +)
    {{ tex \lambda [[x]] \mathpunct{.} [[m]] }}
  | n v :: :: App
    {{ tex [[n]] \gap [[v]] }}
  | case v of inl x ⇒ m1 ; inr y ⇒ m2 :: :: Case
    (+ bind x in m1 +)
    (+ bind y in m2 +)
    {{ tex \kw{case} \gap [[v]] \mathrel{ \kw{of} } \mathopen{\lbrace} \kw{inl} \gap [[x]] \mathbin{\Rightarrow} [[m1]] \mathpunct{;} \kw{inr} \gap [[y]] \mathbin{\Rightarrow} [[m2]] \mathclose{\rbrace} }}
  | case' v of inl x ⇒ m1 ; inr y ⇒ m2 :: S :: CaseAlign
    {{ tex \begin{aligned}[t]
        &\kw{case} \gap [[v]] \mathrel{ \kw{of} } \mathopen{\lbrace}
        \kw{inl} \gap [[x]] \mathbin{\Rightarrow} [[m1]] \mathpunct{;} \\
        &\phantom{\kw{case} \gap [[v]] \mathrel{ \kw{of} } \mathopen{\lbrace} }
        \kw{inr} \gap [[y]] \mathbin{\Rightarrow} [[m2]] \mathclose{\rbrace}
      \end{aligned} }}
  | if v then m1 else m2 :: :: If
    {{ tex \kw{if} \gap [[v]] \mathrel{ \kw{then} } [[m1]] \mathrel{ \kw{else} }[[m2]] }}
  | if v _ :: S :: IfOnly
    {{ tex \kw{if} \gap [[v]] }}
  | if v then m _ :: S :: IfNoElse
    {{ tex \kw{if} \gap [[v]] \mathrel{ \kw{then} } [[m]] }}
  | else m :: S :: IfNoThen
    {{ tex \mathrel{ \kw{else} } [[m]] }}
  | ⟨ m1 , m2 ⟩ :: :: Pair
    {{ tex \langle [[m1]] \mathpunct{,} [[m2]] \rangle }}
  | fst m :: :: Fst
    {{ tex \kw{fst} \gap [[m]] }}
  | snd m :: :: Snd
    {{ tex \kw{snd} \gap [[m]] }}
  | join j x = m1 in m2 :: :: Join
    (+ bind x in m1 +)
    {{ tex \kw{join} \gap [[j]] \gap [[x]] \mathrel{=} [[m1]] \mathrel{ \kw{in} } [[m2]] }}
  | joins p in m :: M :: Joins
    {{ tex \kw{joins} \gap [[p]] \mathrel{ \kw{in} } [[m]] }}
  | jump j v :: :: Jump
    {{ tex \kw{jump} \gap [[j]] \mathrel{ \kw{with} } [[v]] }}
  % plugging metafunctions
  | K [ n ] :: :: Plug
    {{ com plugging into a continuation }}
    {{ tex [[K]] [ [[n]] ] }}
  | k [ n ] :: :: Plugs
    {{ com plugging into a sugared continuation }}
    {{ tex [[k]] [ [[n]] ] }}
  | E [ n ] :: :: Eval
    {{ com plugging into an evaluation context }}
    {{ tex [[E]] [ [[n]] ] }}
  | L [ m ] :: :: Tail
    {{ com plugging into a tail context }}
    {{ tex [[L]] [ [[m]] ] }}
  % substitution metafunctions
  | m { s } :: :: SubstsCom
    {{ com simultaneous substitution into computations }}
    {{ tex [[m]] \mathopen{\lbrace} [[s]] \mathclose{\rbrace} }}
  % syntactic sugar for typesetting
  | _ :: :: Hole
    {{ com hole }}
    {{ tex \relax }}
  | m & :: S :: Align
    {{ com align after }}
    {{ tex [[m]] & }}
  | ( m ) :: S :: Parens
    {{ com parentheses }}
    {{ tex ([[m]]) }}
  | (# m #) :: S :: SParens
    {{ com invisible parentheses }}
    {{ tex [[m]] }}
  % translation
  | ⟦ m ⟧ K :: :: CCNormCom
    {{ tex \llbracket [[m]] \rrbracket [[K]] }}
  | ⟦ m ⟧ k :: :: CCNormComk
    {{ tex \llbracket [[m]] \rrbracket [[k]] }}
  | ⟦ m ⟧ :: S :: CCNormComNil
    {{ tex \llbracket [[m]] \rrbracket }}

tm {{ tex \textit{tm} }} :: 'term_' ::= {{ com terminals }}
  | return v :: :: Return
  | λ x . m :: :: Fun
  | ⟨ m1 , m2 ⟩ :: :: Pair

lc {{ tex \mathit{lc} }}, e :: 'lc_' ::= {{ com lambda calculus terms }}
  | x :: :: Var
    {{ tex \mathit{[[x]]} }}
  | true :: :: True
    {{ tex \kw{true} }}
  | false :: :: False
    {{ tex \kw{false} }}
  | λ x . lc :: :: Fun
    {{ tex \lambda [[x]] \mathpunct{.} [[lc]] }}
  | lc1 lc2 :: :: App
    {{ tex [[lc1]] \gap [[lc2]] }}
  | if lc1 then lc2 else lc3 :: :: If
    {{ tex \kw{if} \gap [[lc1]] \mathrel{ \kw{then} } [[lc2]] \mathrel{ \kw{else} }[[lc3]] }}
  | let x = lc1 in lc2 :: :: Let
    {{ tex \kw{let} \gap [[x]] \mathrel{=} [[lc1]] \mathrel{ \kw{in} } [[lc2]] }}
  | ( lc ) :: S :: Parens
    {{ tex ([[lc]]) }}

E :: 'eval_' ::= {{ com evaluation contexts }}
  | let x ← □ in m :: :: Let
    {{ tex \kw{let} \gap [[x]] \mathrel{\leftarrow} \square \mathrel{ \kw{in} } [[m]] }}
  | □ v :: :: App
    {{ tex \square \gap [[v]] }}
  | fst □ :: :: Fst
    {{ tex \kw{fst} \gap \square }}
  | snd □ :: :: Snd
    {{ tex \kw{snd} \gap \square }}
  | join j x = m in □ :: :: Join
    {{ tex \kw{join} \gap [[j]] \gap [[x]] \mathrel{=} [[m]] \mathrel{ \kw{in} } \square }}

L :: 'tail_' ::= {{ com tail contexts }}
  | let x ← n in □ :: :: Let
    {{ tex \kw{let} \gap [[x]] \mathrel{\leftarrow} [[n]] \mathrel{ \kw{in} } \square }}
  | case v of inl x ⇒ □ ; inr y ⇒ □ :: :: Case
    {{ tex \kw{case} \gap [[v]] \mathrel{ \kw{of} } \mathopen{\lbrace} \kw{inl} \gap [[x]] \mathbin{\Rightarrow} \square \mathpunct{;} \kw{inr} \gap [[y]] \mathbin{\Rightarrow} \square \mathclose{\rbrace} }}

K :: 'Kont_' ::= {{ com continuations }}
  | □ :: :: Empty
    {{ tex \square }}
  | let x ← □ in m :: :: Let
    {{ tex \kw{let} \gap [[x]] \mathrel{\leftarrow} \square \mathrel{ \kw{in} } [[m]] }}
  | K [ k ] :: :: Konts
    {{ tex [[K]] \mathbin{\dblcolon} [[k]] }}
  | K { s } :: :: Subst
    {{ tex [[K]] \mathopen{\lbrace} [[s]] \mathclose{\rbrace} }}
  | k :: M :: Kont
    {{ tex [[k]] }}
  | K [ k1 ] - [ ki ] :: M :: Kontsi
    {{ tex [[K]] \mathbin{\dblcolon} [[k1]] \mathbin{\dblcolon} \dots \mathbin{\dblcolon} [[ki]] }}
  | _ :: :: Hole
    {{ com hole }}
    {{ tex \relax }}
  | ( K ) :: S :: Parens
    {{ tex ([[K]]) }}
  | (# K #) :: S :: SParens
    {{ tex [[K]] }}

k :: 'kont_' ::= {{ com continuations }}
  | K v :: :: App
    {{ tex [[K]] \gap [[v]] }}
  | fst K :: :: Fst
    {{ tex \kw{fst} \gap [[K]] }}
  | snd K :: :: Snd
    {{ tex \kw{snd} \gap [[K]] }}
  | _ :: :: Hole
    {{ com hole }}
    {{ tex \relax }}
  | ( k ) :: S :: Parens
    {{ tex ([[k]]) }}
  | (# k #) :: S :: SParens
    {{ tex [[k]] }}

r {{ tex \rho }}, s {{ tex \sigma }}, t {{ tex \tau }} :: 'subst_' ::= {{ com substitutions }}
  | • :: :: Nil
    {{ tex \cdot }}
  | s , x ↦ v :: :: Cons
    {{ tex [[s]] \mathpunct{,} [[x]] \mathbin{\mapsto} [[v]] }}
  | x ↦ v :: M :: Singleton
    {{ tex [[x]] \mathbin{\mapsto} [[v]] }}
  | ( s ) :: S :: Parens
    {{ tex ([[s]]) }}
  | (# s #) :: S :: SParens
    {{ tex [[s]] }}

J, p {{ tex \varphi }}, q {{ tex \psi }} :: 'join_' ::= {{ com join points }}
  | • :: :: Nil
    {{ tex \square }}
  | J , j x = m :: :: Cons
    {{ tex [[J]] \mathpunct{,} \gap [[j]] \gap [[x]] \mathrel{=} [[m]] }}
  | j x = m :: M :: Singleton
    {{ tex [[j]] \gap [[x]] \mathrel{=} [[m]] }}
  | ( J ) :: S :: Parens
    {{ tex ([[J]]) }}
  | (# J #) :: S :: SParens
    {{ tex [[J]] }}

G {{ tex \Gamma }} :: 'ctxt_' ::= {{ com term contexts }}
  | • :: :: Nil
    {{ tex \cdot }}
  | x : A :: S :: Singleton
    {{ tex [[x]] \mathbin{:} [[A]] }}
  | G , x : A :: :: Cons
    {{ tex [[G]] \mathpunct{,} [[x]] \mathrel{:} [[A]] }}
  | G1 , G2 :: M :: Append
    {{ tex [[G1]] \mathpunct{,} [[G2]] }}

D {{ tex \Delta }} :: 'dtxt_' ::= {{ com join contexts }}
  | • :: :: Nil
    {{ tex \cdot }}
  | j : A ↗ B :: S :: Singleton
    {{ tex [[j]] \mathbin{:} [[A]] \mathbin{\nnearrow}\! [[B]] }}
  | D , j : A ↗ B :: :: Cons
    {{ tex [[D]] \mathpunct{,} [[j]] \mathbin{:} [[A]] \mathbin{\nnearrow}\! [[B]] }}
  | D1 , D2 :: M :: Append
    {{ tex [[D1]] \mathpunct{,} [[D2]] }}

S :: 'set_' ::= {{ com sets }}
  | ⟦ A ⟧ :: :: InterpVal
    {{ tex \llbracket [[A]] \rrbracket }}
  | ⟦ B ⟧ :: :: InterpCom
    {{ tex \llbracket [[B]] \rrbracket }}
  | ⟦ B ⟧* :: :: InterpEval
    {{ tex \llbracket [[B]] \rrbracket^\ast }}

formula :: 'formula_' ::=
  | judgement :: :: judgement
  % syntactics
  | x : A ∈ G :: :: In
    {{ tex [[x]] \mathbin{:} [[A]] \mathrel{\in} [[G]] }}
  | j : A ↗ B ∈ D :: :: Jn
    {{ tex [[j]] \mathbin{:} [[A]] \mathbin{\nnearrow}\! [[B]] \mathrel{\in} [[D]]}}
  | G ⊢ v : A :: :: WtVal
    {{ tex [[G]] \mathrel{\vdash} [[v]] \mathrel{:} [[A]] }}
  | G | D ⊢ m : B :: :: WtCom
    {{ tex [[G]] \mid [[D]] \mathrel{\vdash} [[m]] \mathrel{:} [[B]] }}
  | G | D ⊢ K : B1 ⇒ B2 :: :: WtK
    {{ tex [[G]] \mid [[D]] \mathrel{\vdash} [[K]] \mathrel{:} [[B1]] \Rightarrow [[B2]]}}
  % semantics
  | ( v , w ) ∈ A :: :: LogVal
    {{ tex ( [[v]] \mathpunct{,} [[w]] ) \mathrel{\in} \llbracket [[A]] \rrbracket }}
  | ( m , n ) ∈ B :: :: LogCom
    {{ tex ( [[m]] \mathpunct{,} [[n]] ) \mathrel{\in} \llbracket [[B]] \rrbracket }}
  | ( m , n ) ∈* B :: :: LogEval
    {{ tex ( [[m]] \mathpunct{,} [[n]] ) \mathrel{\in} \llbracket [[B]] \rrbracket^\ast }}
  | ( s , t ) ∈ G :: :: LogSubst
    {{ tex ( [[s]] \mathpunct{,} [[t]] ) \mathrel{\in} \llbracket [[G]] \rrbracket }}
  | ( p , q ) ∈ D :: :: LogJoin
    {{ tex ( [[p]] \mathpunct{,} [[q]] ) \mathrel{\in} \llbracket [[D]] \rrbracket }}
  | G ⊧ v ~ w : A :: :: SemVal
    {{ tex [[G]] \mathrel{\vDash} [[v]] \mathrel{\sim} [[w]] \mathrel{:} [[A]] }}
  | G | D ⊧ m ~ n : B :: :: SemCom
    {{ tex [[G]] \mid [[D]] \mathrel{\vDash} [[m]] \mathrel{\sim} [[n]] \mathrel{:} [[B]] }}
  | G | D ⊧ m \\ ~ n : B :: :: SemComBreak
    {{ tex { \begin{aligned}[t]
        [[G]] \mid [[D]] &\mathrel{\vDash} [[m]] \\[-0.25\baselineskip]
        &\mathrel{\sim} [[n]] \mathrel{:} [[B]]
      \end{aligned} } }}
  | G | D ⊧ K1 ~ K2 : B1 ⇒ B2 :: :: SemKont
    {{ tex [[G]] \mid [[D]] \mathrel{\vDash} [[K1]] \mathrel{\sim} [[K2]] \mathrel{:} [[B1]] \Rightarrow [[B2]] }}
  % evaluation
  | m ⇝ n :: :: Eval
    {{ tex [[m]] \mathbin{\rightsquigarrow} [[n]] }}
  | m ⇝* n :: :: Evals
    {{ tex [[m]] \mathbin{\rightsquigarrow^\ast} [[n]] }}
  | m ⇓ tm :: :: Norm
    {{ tex [[m]] \mathbin{\Downarrow} [[tm]] }}
  | ( formula ) :: S :: parentheses
    {{ tex ([[formula]]) }}

subrules
  T <:: A
  tm <:: m
